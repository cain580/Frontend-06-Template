学习笔记

一、字典树

    储存：下一个字母是上一个字母对象的子集，组成字典树。

    计算重复最多的字符串：遍历字典树每个对象的 $ ，记录数值最大的对象，从树底至树顶依次拼接字符串，得出数量最多字符串。

    思考：
        1、随着数据量增加，或者字符串长度增加，最终会导致字典树出现多个最大字符串为1，这种计算重复字符串的方法将不准确；


二、KMP

    理解与思考：
        1、这种算法在字符串自重复时性能才会达到最优；

        2、如果字符串无自重复，性能甚至比暴力解还要差，毕竟两字符串对比前需要先遍历自重复；

        3、如果字符串本身自重复数量很多，且两字符串对比不匹配，会发现遍历次数会大于 暴力解；


三、Wildcard

    理解：
        1、？符号处理： 每个判断只要涉及 <字母> === ？判断 一律 true；

        2、* 符号处理：

            wildcard(source,pattern) {

                判断 pattern 中* 的个数：

                a、无 * 符号：
                    判断长度是否一致，不一致返回false；

                    从index=0开始向后依次对比，不一致返回false；

                b、1个 * 符号：
                    * 前部分： 从index=0 开始向后依次对比 直至 * ，如果不一致返回 false

                    * 后部分： 从index=-1 开始向前依次对比 直至 * ，如果不一致返回 false

                c、2个 * 符号：
                    先用 b 判断，如返回true则继续执行;

                    两个 * 之间部分： 截取两个 * 之间字符串,使用 KMP 算法判断是否包含

                d、多个 * 符号：
                    先用 c 判断，如返回非false则继续执行;

                    source/pattern 截取两边 * 内的字符串，并重新赋值；

                    判断是否还有* 号;

                    如果有* 号 重新从 * 符号处理开始重新执行 并入参赋值后的 wildcard(source,pattern)

                    如果没有* 号 执行 kmp(source,pattern)

            }