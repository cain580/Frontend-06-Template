<!DOCTYPE html >
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>五子棋</title>
  <style>
    #app{
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap:wrap;
      border: 1px solid #fff;
      background: #9FBBFF;
    }
    .cell{
      width: 50px;
      height: 50px;
      display: flex;
      justify-content: center;
      align-items: center;
      box-sizing: border-box;
      border: 1px solid #fff;
    }
    .black{
      width: 25px;
      height: 25px;
      background: #000;
      border-radius: 50%;
    }
    .white{
      width: 25px;
      height: 25px;
      background: #fff;
      border-radius: 50%;
      box-shadow: .1rem .1rem .05rem rgba(0,0,0,.5)
    }

  </style>
</head>
<body>
  <div id="app"></div>
  <script>
    class Chessboard{
      constructor({boardSize=5,length=5,white,black}){
        //const {boardSize,length} = option || {boardSize:5,length:5};
       this._pattern = Array.from({ length: Math.pow(boardSize, 2) }).map(k=>0);
       //  this._pattern=[
       //    0,0,1,
       //    0,0,2,
       //    0,0,0
       //  ]
        console.log(this._pattern)
        //棋盘尺寸
        this._size = boardSize;
        // 连接长度
        this._length = length || boardSize;
        //1 为白子  2为 黑子
        this.currentRole = 1;
        //白子
        this.white = white;
        // 黑子
        this.black = black;
        //console.log( this._pattern)
        //绘制棋盘
        this.draw();
        //白棋先下
        white.playChess();

      }
      //绘制棋盘
      draw(pattern){
        pattern = pattern || this._pattern;
        let l = this._size;
        let board = document.getElementById("app");
        board.innerHTML = "";
        board.style.width = l*50+"px";

        let setPiece = (_class)=>{
          let p = document.createElement("span");
          p.classList.add(_class);
          return p;
        };
        for(let i=0;i<l;i++){
          for(let j=0;j<l;j++){
            let cell = document.createElement("div");
            cell.classList.add("cell");
            pattern[i*l+j]===2?cell.appendChild(setPiece("black")):
              pattern[i*l+j]===1?cell.appendChild(setPiece("white")):
                cell.addEventListener("click",()=>this.move(j,i));
            //cell.innerText=i*l+j
            board.appendChild(cell);
          }
        }
      }
      //棋盘上添加棋子
      add(x,y,role){
        this._pattern[y*this._size+x] = role;
        this.draw();
      }
      //
      move(x,y){
        let cr = this.currentRole;
        this.add(x,y,cr);
        if(this.check()){
          return setTimeout(()=>{
            alert(cr===2?"黑子获胜！":"白子获胜！");
          })
        }
        this.currentRole = cr = 3 - cr;

        if(cr === 2){
          this.black.playChess(this);
        }else if(cr === 1){
          this.white.playChess(this);
        }
      }
      clone(pattern){
        //return Object.create(pattern);
        return JSON.parse(JSON.stringify(pattern));
      }
      check(pattern,role,target){
        pattern = pattern || this._pattern;

        let cr = role||this.currentRole;
        let l = this._size;
        target = target|| this._length;
        //行
        for(let i=0;i<l;i++){
          let count = 0;
          for(let j=0;j<l;j++){
            if(pattern[i*l+j]===cr){
              count++;
            }else{
              count = 0;
            }
            if(count >= target ){
              return true;
            }
          }
        }
        //列
        for(let i=0;i<l;i++){
          let count = 0;
          for(let j=0;j<l;j++){
            if(pattern[j*l+i]===cr){
              count++;
            }else{
              count = 0;
            }
            if(count>= target ){
              return true;
            }
          }
        }
        //左上 至 右下  偏上
        for(let i=0;i<l;i++){
          {
            let count = 0;
            if(l-i<target) continue;
            for(let j=0;j<l-i;j++){
              if(pattern[j*l+j+i]===cr){
                count++;
              }else{
                count = 0;
              }
              if(count>= target){
                return true;
              }
            }
          }
        }
        //左上 至 右下  偏下
        for(let i=1;i<l;i++){
          let count = 0;
          if(l-i<target) continue;
          for(let j=i;j<l;j++){
            if(pattern[j*l+j-i]===cr){
              count++;
            }else{
              count = 0;
            }
            if(count>= target){
              return true;
            }
          }
        }
        //右上 至 左下  偏下
        for(let i=1;i<l;i++){
          let count = 0;
          if(l-i<target) continue;
          for(let j=i;j<l;j++){
            if(pattern[j*l+(l-1-j)+i]===cr){
              count++;
            }else{
              count = 0;
            }
            if(count>= target){
              return true;
            }
          }
        }
        //右上 至 左下  偏上
        for(let i=0;i<l;i++){
          let count = 0;
          if(l-i<target) continue;
          for(let j=0;j<l-i;j++){
            if(pattern[j*l+(l-1-j)-i]===cr){
              count++;
            }else{
              count = 0;
            }
            if(count>= target){
              return true;
            }
          }
        }

      }
      willWin(pattern,role,target){
        let l = this._size;
        for(let i=0;i<l;i++){
          for(let j=0;j<l;j++){
            if(pattern[i*l+j]) continue;
            let tmp = this.clone(pattern);
            tmp[i*l+j] = role;
            if(this.check(tmp,role,target)){
              return [j,i]
            }
          }
        }
        return null;
      }
      bestChoice(pattern,role,c=3,target){
        target = target|| this._length;
        let point = this.willWin(pattern,role,target)
        if(point){
          return {
            point,
            result:1
          }
        }
        let result = -1;
        let rPoint = null;
        let l = this._size;
        outer: for(let i=0;i<l;i++){
          for(let j=0;j<l;j++){
            if(pattern[i*l+j]) continue;
            let tmp = this.clone(pattern);
            tmp[i*l+j] = role;
            let opp = this.bestChoice(tmp,3-role,c-1,target-1);
            if(-opp.result >= result){
              point = [j,i];
              rPoint = opp.point;
              result = -opp.result;
            }
            console.log("层级："+c,"选手：",role===1?"白子":"黑子","格子-",[j,i],"target:",target,"result:"+opp.result,"point:",opp.point,"rPoint:",opp.rPoint)
            if(result===1) break outer;
          }
        }
        return {
          point:result<0?rPoint:point,
          result:point?result:0
        }
      }
    }
    class Robot {
      constructor(){

      }
      playChess(board){

        let cr = board.currentRole;
        let pattern = board._pattern;


        let choice = board.bestChoice(pattern,cr)
        console.log(choice)
        if(choice.point){
            board.add(choice.point[0],choice.point[1],cr)
          }
        // if(choice.result<=0&&choice.rPoint){
        //   board.add(choice.rPoint[0],choice.rPoint[1],cr)
        // }else if(choice.result>0&&choice.point){
        //   board.add(choice.point[0],choice.point[1],cr)
        // }
        if(board.check(pattern,cr)){
          return setTimeout(()=>{
            alert(cr===2?"黑子获胜！":"白子获胜！");
          })
        }
        board.currentRole = 3-cr;

      }

    }
    class Player {
      constructor(){

      }
      playChess(){
        setTimeout(()=>{
          console.log("请选手下子")
        })

      }
    }
    class Piece{

    }
    const player = new Player();
    const robot = new Robot();
    let currentRole = 1;
    const board = new Chessboard({
      boardSize:10,
      length:5,
      white: player,
      black: robot,
    });








  </script>
</body>
</html>
